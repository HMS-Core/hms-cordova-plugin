{"version":3,"file":"HMSNearby.js","sourceRoot":"","sources":["../src/www/HMSNearby.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n    Copyright 2020-2024. Huawei Technologies Co., Ltd. All rights reserved.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\")\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n        https://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\nimport {\r\n    ChannelPolicy,\r\n    HMSNearbyEvent,\r\n    HMSPermission,\r\n    Policy,\r\n} from \"./enums\";\r\nimport { GetOption, Message, PutOption, BeaconType, BeaconOption } from \"./interfaces\";\r\nimport { asyncExec } from \"./utils\";\r\n\r\nexport {\r\n    HMSNearbyEvent,\r\n    HMSPermission,\r\n    Policy,\r\n    DataType,\r\n    TransferState,\r\n    MessagePolicyDistanceType,\r\n    MessagePolicyFindingMode,\r\n    MessagePolicyTtlSeconds,\r\n    StatusCode,\r\n    ChannelPolicy, \r\n} from \"./enums\";\r\nexport {\r\n    Message,\r\n    EddystoneUid,\r\n    IBeaconId,\r\n    NamespaceType,\r\n    MessagePicker,\r\n    MessagePolicy,\r\n    PutOption,\r\n    GetOption,\r\n    BleSignal,\r\n    Distance,\r\n    EndpointId,\r\n    ConnectInfo,\r\n    ConnectResult,\r\n    ScanEndpointInfo,\r\n    Data,\r\n    TransferStateUpdate,\r\n    BleSignalUpdate,\r\n    DistanceUpdate,\r\n    MessageTimeout,\r\n    PermissionUpdate,\r\n    AuthCodeUpdate,\r\n    BeaconType,\r\n    BeaconOption\r\n} from \"./interfaces\";\r\nexport {\r\n    BLE_UNKNOWN_TX_POWER,\r\n    PRECISION_LOW,\r\n    MAX_SIZE_DATA,\r\n    MAX_CONTENT_SIZE,\r\n    MAX_TYPE_LENGTH,\r\n    MESSAGE_NAMESPACE_RESERVED,\r\n    MESSAGE_TYPE_EDDYSTONE_UID,\r\n    MESSAGE_TYPE_I_BEACON_ID,\r\n    DISTANCE_UNKNOWN,\r\n    MESSAGE_PICKER_INCLUDE_ALL_TYPES,\r\n    MESSAGE_POLICY_DEFAULT,\r\n    MESSAGE_POLICY_BLE_ONLY,\r\n    GET_OPTION_DEFAULT,\r\n    PUT_OPTION_DEFAULT,\r\n} from \"./interfaces\";\r\n\r\nconst CLASS_NAME = \"HMSNearby\";\r\n\r\n//////////////////// LOGGER ////////////////////\r\n\r\n/**\r\n * Enables HMSLogger capability which is used for sending usage analytics of Nearby SDK's methods.\r\n * @returns Promise<void>\r\n */\r\nexport function enableLogger(): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSNearbyBase\", [\"enableLogger\"]);\r\n}\r\n\r\n/**\r\n * Disables HMSLogger capability which is used for sending usage analytics of Nearby SDK's methods.\r\n * @returns Promise<void>\r\n */\r\nexport function disableLogger(): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSNearbyBase\", [\"disableLogger\"]);\r\n}\r\n\r\n//////////////////// PERMISSIONS ////////////////////\r\n\r\n/**\r\n * Checks whether permission is granted to use the services.\r\n * @param {HMSPermission} permission Permission.\r\n * @returns Promise<boolean>\r\n */\r\nexport function hasPermission(permission: HMSPermission): Promise<boolean> {\r\n    return asyncExec(CLASS_NAME, \"HMSNearbyBase\", [\r\n        \"hasPermission\",\r\n        permission,\r\n    ]);\r\n}\r\n\r\n/**\r\n * Obtains the necessary permissions to use the services.\r\n * @param {HMSPermission} permission Permission.\r\n * @returns Promise<void>\r\n */\r\nexport function requestPermission(permission: HMSPermission): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSNearbyBase\", [\r\n        \"requestPermission\",\r\n        permission,\r\n    ]);\r\n}\r\n\r\n/**\r\n * Obtains the necessary permissions to use the services.\r\n * @param {HMSPermission[]} permissions Permissions List.\r\n * @returns Promise<void>\r\n */\r\nexport function requestPermissions(\r\n    permissions: HMSPermission[]\r\n): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSNearbyBase\", [\r\n        \"requestPermissions\",\r\n        permissions,\r\n    ]);\r\n}\r\n\r\n//////////////////// EVENT REGISTERATION ////////////////////\r\n\r\n/**\r\n * Subscribes to Nearby events. Pass a callback to run codes when the event triggered.\r\n * @param {HMSNearbyEvent} event Event name.\r\n * @param {(res: any) => void} callback Callback to be called when the event triggered.\r\n */\r\nexport function on(event: HMSNearbyEvent, callback: (res: any) => void): void {\r\n    window.subscribeHMSEvent(event, callback);\r\n}\r\n\r\n//////////////////// DISCOVERY ////////////////////\r\n\r\n/**\r\n * Starts broadcasting.\r\n * @param {string} name Local endpoint name.\r\n * @param {string} serviceId Service ID. The app package name is recommended.\r\n * @param {Policy} policy Object of the Policy type.\r\n * @returns Promise<void>\r\n */\r\nexport function startBroadcasting(\r\n    name: string,\r\n    serviceId: string,\r\n    policy: Policy\r\n): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSDiscovery\", [\r\n        \"startBroadcasting\",\r\n        name,\r\n        serviceId,\r\n        policy,\r\n    ]);\r\n}\r\n\r\n/**\r\n * Stops broadcasting.\r\n * @returns Promise<void>\r\n */\r\nexport function stopBroadcasting(): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSDiscovery\", [\"stopBroadcasting\"]);\r\n}\r\n\r\n/**\r\n * Starts to scan for remote endpoints with the specified service ID.\r\n * @param {string} serviceId Service ID. The app package name is recommended.\r\n * @param {Policy} policy Object of the Policy type.\r\n * @returns Promise<void>\r\n */\r\nexport function startScan(serviceId: string, policy: Policy): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSDiscovery\", [\r\n        \"startScan\",\r\n        serviceId,\r\n        policy,\r\n    ]);\r\n}\r\n\r\n/**\r\n * Stops discovering devices.\r\n * @returns Promise<void>\r\n */\r\nexport function stopScan(): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSDiscovery\", [\"stopScan\"]);\r\n}\r\n\r\n/**\r\n * Sends a request to connect to a remote endpoint.\r\n * @param {string} name Local endpoint name.\r\n * @param {string} endpointId ID of the remote endpoint.\r\n * @returns Promise<void>\r\n */\r\nexport function requestConnect(\r\n    name: string,\r\n    endpointId: string\r\n): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSDiscovery\", [\r\n        \"requestConnect\",\r\n        name,\r\n        endpointId,\r\n    ]);\r\n}\r\n\r\n/**\r\n * Sends a request to connect to a remote endpoint.\r\n * @param {string} name Local endpoint name.\r\n * @param {string} endpointId ID of the remote endpoint.\r\n * @param {ChannelPolicy} channelPolicy Channel policy, which is used to select the channel for establishing a connection.\r\n * @returns Promise<void>\r\n */\r\nexport function requestConnectEx(\r\n    name: string,\r\n    endpointId: string,\r\n    channelPolicy: ChannelPolicy\r\n): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSDiscovery\", [\r\n        \"requestConnectEx\",\r\n        name,\r\n        endpointId,\r\n        channelPolicy,\r\n    ]);\r\n}\r\n\r\n/**\r\n * Accepts a connection. This API must be called before data transmission. If the connection request is not accepted within 8 seconds, the connection fails and needs to be re-initiated.\r\n * @param {string} endpointId ID of the remote endpoint.\r\n * @returns Promise<void>\r\n */\r\nexport function acceptConnect(endpointId: string): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSDiscovery\", [\"acceptConnect\", endpointId]);\r\n}\r\n\r\n/**\r\n * Rejects a connection request from a remote endpoint.\r\n * @param {string} endpointId ID of the remote endpoint.\r\n * @returns Promise<void>\r\n */\r\nexport function rejectConnect(endpointId: string): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSDiscovery\", [\"rejectConnect\", endpointId]);\r\n}\r\n\r\n/**\r\n * Disconnects from a remote endpoint. Then communication with the remote endpoint is no longer available.\r\n * @param {string} endpointId ID of the remote endpoint.\r\n * @returns Promise<void>\r\n */\r\nexport function disconnect(endpointId: string): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSDiscovery\", [\"disconnect\", endpointId]);\r\n}\r\n\r\n/**\r\n * Disconnects all connections.\r\n * @returns Promise<void>\r\n */\r\nexport function disconnectAll(): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSDiscovery\", [\"disconnectAll\"]);\r\n}\r\n\r\n//////////////////// TRANSFER ////////////////////\r\n\r\n/**\r\n * Transfers given bytes to given endpoint ids.\r\n * @param {number[]} bytes number array that contains your data.\r\n * @param {string[]} endpointIds string array of remote endpoint IDs.\r\n * @returns Promise<void>\r\n */\r\nexport function sendBytes(\r\n    bytes: number[],\r\n    endpointIds: string[]\r\n): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSTransfer\", [\r\n        \"sendBytes\",\r\n        bytes,\r\n        endpointIds,\r\n    ]);\r\n}\r\n\r\n/**\r\n * Transfers file from given URI to given endpoint ids. Transferred file is saved in subscriber's device under Downloads/Nearby/ directory with name data id.\r\n * @param {string} fileUri File URI.\r\n * @param {string[]} endpointIds string array of remote endpoint IDs.\r\n * @returns Promise<void>\r\n */\r\nexport function sendFile(\r\n    fileUri: string,\r\n    endpointIds: string[]\r\n): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSTransfer\", [\r\n        \"sendFile\",\r\n        fileUri,\r\n        endpointIds,\r\n    ]);\r\n}\r\n\r\n/**\r\n * Transfers stream from given URL to given endpoint ids.\r\n * @param {string} streamUrl Stream URL.\r\n * @param {string[]} endpointIds string array of remote endpoint IDs.\r\n * @returns Promise<void>\r\n */\r\nexport function sendStream(\r\n    streamUrl: string,\r\n    endpointIds: string[]\r\n): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSTransfer\", [\r\n        \"sendStream\",\r\n        streamUrl,\r\n        endpointIds,\r\n    ]);\r\n}\r\n\r\n/**\r\n * Cancels data transmission when sending or receiving data.\r\n * @param {string} dataId ID of the data whose transmission is to be canceled.\r\n * @returns Promise<void>\r\n */\r\nexport function cancelDataTransfer(dataId: string): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSTransfer\", [\"cancelDataTransfer\", dataId]);\r\n}\r\n\r\n//////////////////// MESSAGE ////////////////////\r\n\r\n/**\r\n * Obtains the current API credential.\r\n * @returns Promise<string> Promise result of an execution that returns the current API credential.\r\n */\r\nexport function getApiKey(): Promise<string> {\r\n    return asyncExec(CLASS_NAME, \"HMSNearbyBase\", [\"getApiKey\"]);\r\n}\r\n\r\n/**\r\n * Sets the API credential for your app.\r\n * @param {string} apiKey API credential.\r\n * @returns Promise<void>\r\n */\r\nexport function setApiKey(apiKey: string): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSNearbyBase\", [\"setApiKey\", apiKey]);\r\n}\r\n\r\n/**\r\n * Publishes a message and broadcasts a token for nearby devices to scan.\r\n * @param {Message} message Published message.\r\n * @returns Promise<void>\r\n */\r\nexport function put(message: Message): Promise<void>;\r\n/**\r\n * Publishes a message and broadcasts a token for nearby devices to scan. This message is published only to apps that use the same project ID and have registered the message type with the cloud for subscription.\r\n * @param {Message} message Published message.\r\n * @param {PutOption} putOption PutOption parameters.\r\n * @returns Promise<void>\r\n */\r\nexport function put(message: Message, putOption: PutOption): Promise<void>;\r\nexport function put(message: Message, putOption?: PutOption): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSMessage\", [\"put\", message, putOption]);\r\n}\r\n\r\n/**\r\n * Obtains messages from the cloud using the default option (DEFAULT).\r\n * @returns Promise<void>\r\n */\r\nexport function get(): Promise<void>;\r\n/**\r\n * Registers the messages to be obtained with the cloud. Only messages with the same project ID can be obtained.\r\n * @param {GetOption} getOption\r\n * @returns Promise<void>\r\n */\r\nexport function get(getOption: GetOption): Promise<void>;\r\nexport function get(getOption?: GetOption): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSMessage\", [\"get\", getOption]);\r\n}\r\n\r\n/**\r\n * Identifies only BLE beacon messages. It subscribes to messages published by nearby devices in a persistent and low-power manner and uses the default configuration (DEFAULT). Scanning is going on no matter whether your app runs in the background or foreground. The scanning stops when the app process is killed.\r\n * @returns Promise<void>\r\n */\r\nexport function getInBackground(): Promise<void>;\r\n/**\r\n * Identifies only BLE beacon messages. Scanning is going on no matter whether your app runs in the background or foreground. The scanning stops when the app process is killed.\r\n * @param {GetOption} getOption\r\n * @returns Promise<void>\r\n */\r\nexport function getInBackground(getOption: GetOption): Promise<void>;\r\nexport function getInBackground(getOption?: GetOption): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSMessage\", [\"getInBackground\", getOption]);\r\n}\r\n\r\n/**\r\n * Cancels message publishing.\r\n * @param {Message} message Published message.\r\n * @returns Promise<void>\r\n */\r\nexport function unput(message: Message): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSMessage\", [\"unput\", message]);\r\n}\r\n\r\n/**\r\n * Cancels a message subscription.\r\n * @returns Promise<void>\r\n */\r\nexport function unget(): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSMessage\", [\"unget\"]);\r\n}\r\n\r\n/**\r\n * Cancels the current message subscription.\r\n * @returns Promise<void>\r\n */\r\nexport function ungetInBackground(): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSMessage\", [\"ungetInBackground\"]);\r\n}\r\n\r\n//////////////////// Beacon ////////////////////\r\n\r\nexport function registerScanTask(beaconOption: BeaconOption): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSBeacon\", [\r\n        \"registerScanTask\", beaconOption\r\n    ]);\r\n}\r\n\r\n/**\r\n * Disables the Wi-Fi sharing function.\r\n * @returns Promise<void>\r\n */\r\nexport function unRegisterScanTask(): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSBeacon\", [\"unRegisterScanTask\"]);\r\n}\r\n\r\nexport function getBeaconMsgConditions(): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSBeacon\", [\"getBeaconMsgConditions\"]);\r\n}\r\n\r\nexport function getRawBeaconConditions(): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSBeacon\", [\"getRawBeaconConditions\",]);\r\n}\r\n\r\nexport function getRawBeaconConditionsWithBeaconType(beaconType: BeaconType): Promise<void> {\r\n    return asyncExec(CLASS_NAME, \"HMSBeacon\", [\"getRawBeaconConditionsWithBeaconType\",beaconType]);\r\n}\r\n\r\n//////////////////// VERSION ////////////////////\r\n\r\n/**\r\n * Obtains the Nearby Service SDK version number.\r\n * @returns Promise<string> Version number of the Nearby Service SDK.\r\n */\r\nexport function getVersion(): Promise<string> {\r\n    return asyncExec(CLASS_NAME, \"HMSNearbyBase\", [\"getVersion\"]);\r\n}\r\n"]}